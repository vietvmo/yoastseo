{"version":3,"sources":["../../../src/stringProcessing/SentenceTokenizer.js"],"names":["map","isUndefined","isNaN","core","normalize","normalizeQuotes","fullStop","sentenceDelimiters","fullStopRegex","RegExp","sentenceDelimiterRegex","sentenceRegex","smallerThanContentRegex","htmlStartRegex","htmlEndRegex","blockStartRegex","blockEndRegex","sentenceEndRegex","SentenceTokenizer","isNumber","character","parseInt","isBreakTag","htmlTag","test","isQuotation","isPunctuation","removeDuplicateWhitespace","text","replace","isCapitalLetter","toLocaleLowerCase","isSmallerThanSign","getNextTwoCharacters","nextTokens","next","src","isValidSentenceBeginning","sentenceBeginning","isSentenceStart","token","type","tokenizeSmallerThanContent","tokenSentences","currentSentence","localText","substring","tokenizerResult","createTokenizer","tokenize","tokenizer","localSentences","getSentencesFromTokens","tokens","push","length","shift","lastSentence","pop","forEach","sentence","match","addRule","onText","end","e","console","error","tokenizer2","tokenArray","trimSentences","nextSentenceStart","sliced","firstToken","lastToken","slice","i","hasNextSentence","nextCharacters","tokenizeResults","nextToken","secondToNextToken","trim"],"mappings":"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","file":"SentenceTokenizer.js","sourcesContent":["import { map } from \"lodash-es\";\nimport { isUndefined } from \"lodash-es\";\nimport { isNaN } from \"lodash-es\";\n\nimport core from \"tokenizer2/core\";\n\nimport { normalize as normalizeQuotes } from \"../stringProcessing/quotes.js\";\n\n// All characters that indicate a sentence delimiter.\nconst fullStop = \".\";\n// The \\u2026 character is an ellipsis\nconst sentenceDelimiters = \"?!;\\u2026\";\n\nconst fullStopRegex = new RegExp( \"^[\" + fullStop + \"]$\" );\nconst sentenceDelimiterRegex = new RegExp( \"^[\" + sentenceDelimiters + \"]$\" );\nconst sentenceRegex = new RegExp( \"^[^\" + fullStop + sentenceDelimiters + \"<\\\\(\\\\)\\\\[\\\\]]+$\" );\nconst smallerThanContentRegex = /^<[^><]*$/;\nconst htmlStartRegex = /^<([^>\\s/]+)[^>]*>$/mi;\nconst htmlEndRegex = /^<\\/([^>\\s]+)[^>]*>$/mi;\n\nconst blockStartRegex = /^\\s*[[({]\\s*$/;\nconst blockEndRegex = /^\\s*[\\])}]\\s*$/;\n\nconst sentenceEndRegex = new RegExp( \"[\" + fullStop + sentenceDelimiters + \"]$\" );\n\n/**\n * Class for tokenizing a (html) text into sentences.\n */\nexport default class SentenceTokenizer {\n\t/**\n\t * Returns whether or not a certain character is a number.\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether or not the character is a capital letter.\n\t */\n\tisNumber( character ) {\n\t\treturn ! isNaN( parseInt( character, 10 ) );\n\t}\n\n\t/**\n\t * Returns whether or not a given HTML tag is a break tag.\n\t *\n\t * @param {string} htmlTag The HTML tag to check.\n\t * @returns {boolean} Whether or not the given HTML tag is a break tag.\n\t */\n\tisBreakTag( htmlTag ) {\n\t\treturn /<br/.test( htmlTag );\n\t}\n\n\t/**\n\t * Returns whether or not a given character is quotation mark.\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether or not the given character is a quotation mark.\n\t */\n\tisQuotation( character ) {\n\t\tcharacter = normalizeQuotes( character );\n\n\t\treturn \"'\" === character ||\n\t\t\t\"\\\"\" === character;\n\t}\n\n\t/**\n\t * Returns whether or not a given character is a punctuation mark that can be at the beginning\n\t * of a sentence, like ¿ and ¡ used in Spanish.\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether or not the given character is a punctuation mark.\n\t */\n\tisPunctuation( character ) {\n\t\treturn \"¿\" === character ||\n\t\t\t\"¡\" === character;\n\t}\n\n\t/**\n\t * Removes duplicate whitespace from a given text.\n\t *\n\t * @param {string} text The text with duplicate whitespace.\n\t * @returns {string} The text without duplicate whitespace.\n\t */\n\tremoveDuplicateWhitespace( text ) {\n\t\treturn text.replace( /\\s+/, \" \" );\n\t}\n\n\t/**\n\t * Returns whether or not a certain character is a capital letter.\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether or not the character is a capital letter.\n\t */\n\tisCapitalLetter( character ) {\n\t\treturn character !== character.toLocaleLowerCase();\n\t}\n\n\t/**\n\t * Checks whether the given character is a smaller than sign.\n\t *\n\t * This function is used to make sure that tokenizing the content after\n\t * the smaller than sign works as expected.\n\t * E.g. 'A sentence. < Hello world!' = ['A sentence.', '< Hello world!'].\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether the character is a smaller than sign ('<') or not.\n\t */\n\tisSmallerThanSign( character ) {\n\t\treturn character === \"<\";\n\t}\n\n\t/**\n\t * Retrieves the next two characters from an array with the two next tokens.\n\t *\n\t * @param {Array} nextTokens The two next tokens. Might be undefined.\n\t * @returns {string} The next two characters.\n\t */\n\tgetNextTwoCharacters( nextTokens ) {\n\t\tlet next = \"\";\n\n\t\tif ( ! isUndefined( nextTokens[ 0 ] ) ) {\n\t\t\tnext += nextTokens[ 0 ].src;\n\t\t}\n\n\t\tif ( ! isUndefined( nextTokens[ 1 ] ) ) {\n\t\t\tnext += nextTokens[ 1 ].src;\n\t\t}\n\n\t\tnext = this.removeDuplicateWhitespace( next );\n\n\t\treturn next;\n\t}\n\n\t/**\n\t * Checks if the sentenceBeginning beginning is a valid beginning.\n\t *\n\t * @param {string} sentenceBeginning The beginning of the sentence to validate.\n\t * @returns {boolean} Returns true if it is a valid beginning, false if it is not.\n\t */\n\tisValidSentenceBeginning( sentenceBeginning ) {\n\t\treturn (\n\t\t\tthis.isCapitalLetter( sentenceBeginning ) ||\n\t\t\tthis.isNumber( sentenceBeginning ) ||\n\t\t\tthis.isQuotation( sentenceBeginning ) ||\n\t\t\tthis.isPunctuation( sentenceBeginning ) ||\n\t\t\tthis.isSmallerThanSign( sentenceBeginning )\n\t\t);\n\t}\n\n\t/**\n\t * Checks if the token is a valid sentence ending.\n\t *\n\t * @param {Object} token The token to validate.\n\t * @returns {boolean} Returns true if the token is valid ending, false if it is not.\n\t */\n\tisSentenceStart( token ) {\n\t\treturn ( ! isUndefined( token ) && (\n\t\t\t\"html-start\" === token.type ||\n\t\t\t\"html-end\" === token.type ||\n\t\t\t\"block-start\" === token.type\n\t\t) );\n\t}\n\n\t/**\n\t * Tokens that represent a '<', followed by content until it enters another '<' or '>'\n\t * gets another pass by the tokenizer.\n\t *\n\t * @param {Object} token A token of type 'smaller-than-sign-content'.\n\t * @param {string[]} tokenSentences The current array of found sentences. Sentences may get added by this method.\n\t * @param {string} currentSentence The current sentence. Sentence parts may get appended by this method.\n\t * @returns {{tokenSentences, currentSentence}} The found sentences and the current sentence, appended when necessary.\n\t */\n\ttokenizeSmallerThanContent( token, tokenSentences, currentSentence ) {\n\t\t/*\n\t\t\tRemove the '<' from the text, to avoid matching this rule\n\t\t\trecursively again and again.\n\t\t\tWe add it again later on.\n\t\t*/\n\t\tconst localText = token.src.substring( 1 );\n\n\t\t// Tokenize the current smaller-than-content token without the first '<'.\n\t\tconst tokenizerResult = this.createTokenizer();\n\t\tthis.tokenize( tokenizerResult.tokenizer, localText );\n\t\tconst localSentences = this.getSentencesFromTokens( tokenizerResult.tokens, false );\n\n\t\tlocalSentences[ 0 ] = isUndefined( localSentences[ 0 ] ) ? \"<\" : \"<\" + localSentences[ 0 ];\n\n\t\t/*\n\t\t * When the first sentence has a valid sentence beginning.\n\t\t * Add the currently build sentence to the sentences.\n\t\t * Start building the next sentence.\n\t\t */\n\t\tif ( this.isValidSentenceBeginning( localSentences[ 0 ] ) ) {\n\t\t\ttokenSentences.push( currentSentence );\n\t\t\tcurrentSentence = \"\";\n\t\t}\n\t\tcurrentSentence += localSentences[ 0 ];\n\n\t\tif ( localSentences.length > 1 ) {\n\t\t\t/*\n\t\t\t\tThere is a new sentence after the first,\n\t\t\t\tadd and reset the current sentence.\n\t\t\t */\n\t\t\ttokenSentences.push( currentSentence );\n\t\t\tcurrentSentence = \"\";\n\n\t\t\t// Remove the first sentence (we do not need to add it again).\n\t\t\tlocalSentences.shift();\n\t\t\t// Last sentence gets special treatment.\n\t\t\tconst lastSentence = localSentences.pop();\n\n\t\t\t// Add the remaining found sentences.\n\t\t\tlocalSentences.forEach( sentence => {\n\t\t\t\ttokenSentences.push( sentence );\n\t\t\t} );\n\n\t\t\t// Check if the last sentence has a valid sentence ending.\n\t\t\tif ( lastSentence.match( sentenceEndRegex ) ) {\n\t\t\t\t// If so, add it as a sentence.\n\t\t\t\ttokenSentences.push( lastSentence );\n\t\t\t} else {\n\t\t\t\t// If not, start making a new one.\n\t\t\t\tcurrentSentence = lastSentence;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttokenSentences,\n\t\t\tcurrentSentence,\n\t\t};\n\t}\n\n\t/**\n\t * Creates a tokenizer.\n\t *\n\t * @returns {Object} The tokenizer and the tokens.\n\t */\n\tcreateTokenizer() {\n\t\tconst tokens = [];\n\t\tconst tokenizer = core( function( token ) {\n\t\t\ttokens.push( token );\n\t\t} );\n\n\t\ttokenizer.addRule( fullStopRegex, \"full-stop\" );\n\t\ttokenizer.addRule( smallerThanContentRegex, \"smaller-than-sign-content\" );\n\t\ttokenizer.addRule( htmlStartRegex, \"html-start\" );\n\t\ttokenizer.addRule( htmlEndRegex, \"html-end\" );\n\t\ttokenizer.addRule( blockStartRegex, \"block-start\" );\n\t\ttokenizer.addRule( blockEndRegex, \"block-end\" );\n\t\ttokenizer.addRule( sentenceDelimiterRegex, \"sentence-delimiter\" );\n\t\ttokenizer.addRule( sentenceRegex, \"sentence\" );\n\n\t\treturn {\n\t\t\ttokenizer,\n\t\t\ttokens,\n\t\t};\n\t}\n\n\t/**\n\t * Tokenizes the given text using the given tokenizer.\n\t *\n\t * @param {Object} tokenizer The tokenizer to use.\n\t * @param {string} text The text to tokenize.\n\t * @returns {void}\n\t */\n\ttokenize( tokenizer, text ) {\n\t\ttokenizer.onText( text );\n\n\t\ttry {\n\t\t\ttokenizer.end();\n\t\t} catch ( e ) {\n\t\t\tconsole.error( \"Tokenizer end error:\", e, e.tokenizer2 );\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array of sentences for a given array of tokens, assumes that the text has already been split into blocks.\n\t *\n\t * @param {Object[]} tokenArray The tokens from the sentence tokenizer.\n\t * @param {boolean} [trimSentences=true] Whether to trim the sentences at the end or not.\n\t *\n\t * @returns {string[]} A list of sentences.\n\t */\n\tgetSentencesFromTokens( tokenArray, trimSentences = true ) {\n\t\tlet tokenSentences = [], currentSentence = \"\", nextSentenceStart, sliced;\n\n\t\t// Drop the first and last HTML tag if both are present.\n\t\tdo {\n\t\t\tsliced = false;\n\t\t\tconst firstToken = tokenArray[ 0 ];\n\t\t\tconst lastToken = tokenArray[ tokenArray.length - 1 ];\n\n\t\t\tif ( firstToken && lastToken && firstToken.type === \"html-start\" && lastToken.type === \"html-end\" ) {\n\t\t\t\ttokenArray = tokenArray.slice( 1, tokenArray.length - 1 );\n\n\t\t\t\tsliced = true;\n\t\t\t}\n\t\t} while ( sliced && tokenArray.length > 1 );\n\n\t\ttokenArray.forEach( ( token, i ) => {\n\t\t\tlet hasNextSentence, nextCharacters, tokenizeResults;\n\t\t\tconst nextToken = tokenArray[ i + 1 ];\n\t\t\tconst secondToNextToken = tokenArray[ i + 2 ];\n\n\t\t\tswitch ( token.type ) {\n\t\t\t\tcase \"html-start\":\n\t\t\t\tcase \"html-end\":\n\t\t\t\t\tif ( this.isBreakTag( token.src ) ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = \"\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentSentence += token.src;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"smaller-than-sign-content\":\n\t\t\t\t\ttokenizeResults = this.tokenizeSmallerThanContent( token, tokenSentences, currentSentence );\n\t\t\t\t\ttokenSentences = tokenizeResults.tokenSentences;\n\t\t\t\t\tcurrentSentence = tokenizeResults.currentSentence;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sentence\":\n\t\t\t\t\tcurrentSentence += token.src;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sentence-delimiter\":\n\t\t\t\t\tcurrentSentence += token.src;\n\n\t\t\t\t\tif ( ! isUndefined( nextToken ) && \"block-end\" !== nextToken.type && \"sentence-delimiter\" !== nextToken.type ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"full-stop\":\n\t\t\t\t\tcurrentSentence += token.src;\n\n\t\t\t\t\tnextCharacters = this.getNextTwoCharacters( [ nextToken, secondToNextToken ] );\n\n\t\t\t\t\t// For a new sentence we need to check the next two characters.\n\t\t\t\t\thasNextSentence = nextCharacters.length >= 2;\n\t\t\t\t\tnextSentenceStart = hasNextSentence ? nextCharacters[ 1 ] : \"\";\n\t\t\t\t\t// If the next character is a number, never split. For example: IPv4-numbers.\n\t\t\t\t\tif ( hasNextSentence && this.isNumber( nextCharacters[ 0 ] ) ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// Only split on sentence delimiters when the next sentence looks like the start of a sentence.\n\t\t\t\t\tif ( ( hasNextSentence && this.isValidSentenceBeginning( nextSentenceStart ) ) || this.isSentenceStart( nextToken ) ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"block-start\":\n\t\t\t\t\tcurrentSentence += token.src;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"block-end\":\n\t\t\t\t\tcurrentSentence += token.src;\n\n\t\t\t\t\tnextCharacters = this.getNextTwoCharacters( [ nextToken, secondToNextToken ] );\n\n\t\t\t\t\t// For a new sentence we need to check the next two characters.\n\t\t\t\t\thasNextSentence = nextCharacters.length >= 2;\n\t\t\t\t\tnextSentenceStart = hasNextSentence ? nextCharacters[ 0 ] : \"\";\n\t\t\t\t\t// If the next character is a number, never split. For example: IPv4-numbers.\n\t\t\t\t\tif ( hasNextSentence && this.isNumber( nextCharacters[ 0 ] ) ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( hasNextSentence && this.isValidSentenceBeginning( nextSentenceStart ) ) || this.isSentenceStart( nextToken ) ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} );\n\n\t\tif ( \"\" !== currentSentence ) {\n\t\t\ttokenSentences.push( currentSentence );\n\t\t}\n\n\t\tif ( trimSentences ) {\n\t\t\ttokenSentences = map( tokenSentences, function( sentence ) {\n\t\t\t\treturn sentence.trim();\n\t\t\t} );\n\t\t}\n\n\t\treturn tokenSentences;\n\t}\n}\n"]}