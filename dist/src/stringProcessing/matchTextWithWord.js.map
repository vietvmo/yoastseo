{"version":3,"sources":["../../../src/stringProcessing/matchTextWithWord.js"],"names":["stripSomeTags","stripSpaces","removePunctuation","unifyAllSpaces","unifyWhitespace","matchStringWithTransliteration","normalize","normalizeQuotes","map","text","wordToMatch","locale","extraBoundary","matches","keyword","positions","indexOf","count","length","position","Math","min"],"mappings":"AAAA;;AAEA,OAAOA,aAAP,MAA0B,yCAA1B;;AAEA,OAAOC,WAAP,MAAwB,oCAAxB;AACA,OAAOC,iBAAP,MAA8B,0CAA9B;AACA,SAASC,kBAAkBC,eAA3B,QAAkD,wCAAlD;AACA,OAAOC,8BAAP,MAA2C,qDAA3C;AACA,SAASC,aAAaC,eAAtB,QAA6C,+BAA7C;AACA,SAASC,GAAT,QAAoB,WAApB;;AAEA;;;;;;;;;AASA,eAAe,UAAUC,IAAV,EAAgBC,WAAhB,EAA6BC,MAA7B,EAAqCC,aAArC,EAAqD;AACnEH,QAAOT,cAAeS,IAAf,CAAP;AACAA,QAAOL,gBAAiBK,IAAjB,CAAP;AACAA,QAAOF,gBAAiBE,IAAjB,CAAP;AACAC,eAAcT,YAAaM,gBAAiBG,WAAjB,CAAb,CAAd;;AAEA,KAAIG,UAAUR,+BAAgCI,IAAhC,EAAsCC,WAAtC,EAAmDC,MAAnD,EAA2DC,aAA3D,CAAd;AACAC,WAAUL,IAAKK,OAAL,EAAc,UAAUC,OAAV,EAAoB;AAC3C,SAAOb,YAAaC,kBAAmBY,OAAnB,CAAb,CAAP;AACA,EAFS,CAAV;;AAIA;AACA,OAAMC,YAAYP,IAAKK,OAAL,EAAc,UAAUC,OAAV,EAAoB;AACnD,SAAOL,KAAKO,OAAL,CAAcF,OAAd,CAAP;AACA,EAFiB,CAAlB;;AAIA,QAAO;AACNG,SAAOJ,QAAQK,MADT;AAENL,WAASA,OAFH;AAGNM,YAAUC,KAAKC,GAAL,CAAU,GAAGN,SAAb;AAHJ,EAAP;AAKA","file":"matchTextWithWord.js","sourcesContent":["/** @module stringProcessing/matchTextWithWord */\n\nimport stripSomeTags from \"../stringProcessing/stripNonTextTags.js\";\n\nimport stripSpaces from \"../stringProcessing/stripSpaces.js\";\nimport removePunctuation from \"../stringProcessing/removePunctuation.js\";\nimport { unifyAllSpaces as unifyWhitespace } from \"../stringProcessing/unifyWhitespace.js\";\nimport matchStringWithTransliteration from \"../stringProcessing/matchTextWithTransliteration.js\";\nimport { normalize as normalizeQuotes } from \"../stringProcessing/quotes.js\";\nimport { map } from \"lodash-es\";\n\n/**\n * Returns the number of matches in a given string\n *\n * @param {string} text The text to use for matching the wordToMatch.\n * @param {string} wordToMatch The word to match in the text\n * @param {string} locale The locale used for transliteration.\n * @param {string} [extraBoundary] An extra string that can be added to the wordboundary regex\n * @returns {Object} The matches found and the number of matches.\n */\nexport default function( text, wordToMatch, locale, extraBoundary ) {\n\ttext = stripSomeTags( text );\n\ttext = unifyWhitespace( text );\n\ttext = normalizeQuotes( text );\n\twordToMatch = stripSpaces( normalizeQuotes( wordToMatch ) );\n\n\tlet matches = matchStringWithTransliteration( text, wordToMatch, locale, extraBoundary );\n\tmatches = map( matches, function( keyword ) {\n\t\treturn stripSpaces( removePunctuation( keyword ) );\n\t} );\n\n\t// Create an array of positions of matches to determine where in the text the wordToMatch occurred first.\n\tconst positions = map( matches, function( keyword ) {\n\t\treturn text.indexOf( keyword );\n\t} );\n\n\treturn {\n\t\tcount: matches.length,\n\t\tmatches: matches,\n\t\tposition: Math.min( ...positions ),\n\t};\n}\n"]}