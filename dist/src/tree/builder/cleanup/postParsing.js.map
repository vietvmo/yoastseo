{"version":3,"sources":["../../../../../src/tree/builder/cleanup/postParsing.js"],"names":["LeafNode","Ignored","calculateTextIndices","getElementContent","calculateSourceIndices","element","location","sourceStartIndex","startOffset","sourceEndIndex","endOffset","deleteParseParameters","namespace","tagName","documentMode","cleanUpNode","node","html","content","textContainer","formatting","map","setEndIndexRootNode","tree","endIndexRootNode","forEach","Math","max","cleanUpTree"],"mappings":"AAAA,SAASA,QAAT,QAAyB,iBAAzB;AACA,OAAOC,OAAP,MAAoB,+BAApB;AACA,OAAOC,oBAAP,MAAiC,wBAAjC;AACA,OAAOC,iBAAP,MAA8B,qBAA9B;;AAEA;;;;;;;;;;AAUA,MAAMC,yBAAyB,UAAUC,OAAV,EAAoB;AAClD,MAAKA,QAAQC,QAAb,EAAwB;AACvBD,YAAQE,gBAAR,GAA2BF,QAAQC,QAAR,CAAiBE,WAA5C;AACAH,YAAQI,cAAR,GAAyBJ,QAAQC,QAAR,CAAiBI,SAA1C;AACA;AACD,CALD;;AAOA;;;;;;;;;;AAUA,MAAMC,wBAAwB,UAAUN,OAAV,EAAoB;AACjD,SAAOA,QAAQC,QAAf;AACA,SAAOD,QAAQO,SAAf;AACA,SAAOP,QAAQQ,OAAf;AACA,SAAOR,QAAQS,YAAf;AACA,CALD;;AAOA;;;;;;;;;;AAUA,MAAMC,cAAc,UAAUC,IAAV,EAAgBC,IAAhB,EAAuB;AAC1C;AACA,MAAKD,gBAAgBf,OAArB,EAA+B;AAC9Be,SAAKE,OAAL,GAAef,kBAAmBa,IAAnB,EAAyBC,IAAzB,CAAf;AACA;;AAED;AACA,MAAKD,gBAAgBhB,QAArB,EAAgC;AAC/B;AACAE,yBAAsBc,IAAtB,EAA4BC,IAA5B;AACAD,SAAKG,aAAL,CAAmBC,UAAnB,GAAgCJ,KAAKG,aAAL,CAAmBC,UAAnB,CAA8BC,GAA9B,CAAmChB,WAAW;AAC7E;AACAD,6BAAwBC,OAAxB;AACAM,4BAAuBN,OAAvB;;AAEA,aAAOA,OAAP;AACA,KAN+B,CAAhC;AAOA;;AAEDD,yBAAwBY,IAAxB;AACAL,wBAAuBK,IAAvB;;AAEA,SAAOA,IAAP;AACA,CAvBD;;AAyBA;;;;;;;;;AASA,MAAMM,sBAAsB,UAAUC,IAAV,EAAiB;AAC5C,MAAIC,mBAAmB,CAAvB;AACAD,OAAKE,OAAL,CAAcT,QAAQ;AACrBQ,uBAAmBE,KAAKC,GAAL,CAAUX,KAAKP,cAAf,EAA+Be,gBAA/B,CAAnB;AACA,GAFD;AAGAD,OAAKd,cAAL,GAAsBe,gBAAtB;AACA,CAND;;AAQA;;;;;;;;;;;;;AAaA,MAAMI,cAAc,UAAUL,IAAV,EAAgBN,IAAhB,EAAuB;AAC1CM,OAAKF,GAAL,CAAUL,QAAQD,YAAaC,IAAb,EAAmBC,IAAnB,CAAlB;AACAK,sBAAqBC,IAArB;AACA,SAAOA,IAAP;AACA,CAJD;;AAMA,eAAeK,WAAf","file":"postParsing.js","sourcesContent":["import { LeafNode } from \"../../structure\";\nimport Ignored from \"../../structure/nodes/Ignored\";\nimport calculateTextIndices from \"./calculateTextIndices\";\nimport getElementContent from \"./getElementContent\";\n\n/**\n * Calculates the start and end index of the given node or formatting element,\n * based on its source code location as parsed by `parse5`.\n *\n * @param {module:tree/structure.Node|module:tree/structure.FormattingElement} element  The element to set the start and end index of\n *\n * @returns {void}\n *\n * @private\n */\nconst calculateSourceIndices = function( element ) {\n\tif ( element.location ) {\n\t\telement.sourceStartIndex = element.location.startOffset;\n\t\telement.sourceEndIndex = element.location.endOffset;\n\t}\n};\n\n/**\n * Deletes parameters from the element that are used during parsing,\n * but are not needed for analysis.\n *\n * @param {Object} element  The element to delete parameters of.\n *\n * @returns {void}\n *\n * @private\n */\nconst deleteParseParameters = function( element ) {\n\tdelete element.location;\n\tdelete element.namespace;\n\tdelete element.tagName;\n\tdelete element.documentMode;\n};\n\n/**\n * Cleans up a node in the tree.\n *\n * @param {module:tree/structure.Node} node The node that needs to be cleaned.\n * @param {string} html                     The original html source code from which the node has been parsed.\n *\n * @returns {module:tree/structure.Node} The cleaned up node.\n *\n * @private\n */\nconst cleanUpNode = function( node, html ) {\n\t// Set content of ignored node, based on original source code.\n\tif ( node instanceof Ignored ) {\n\t\tnode.content = getElementContent( node, html );\n\t}\n\n\t// Clean up formatting elements in headings and paragraphs.\n\tif ( node instanceof LeafNode ) {\n\t\t// Start and end position in leaf node's (header's or paragraph's) text without formatting.\n\t\tcalculateTextIndices( node, html );\n\t\tnode.textContainer.formatting = node.textContainer.formatting.map( element => {\n\t\t\t// Start and end position in text **with** formatting.\n\t\t\tcalculateSourceIndices( element );\n\t\t\tdeleteParseParameters( element );\n\n\t\t\treturn element;\n\t\t} );\n\t}\n\n\tcalculateSourceIndices( node );\n\tdeleteParseParameters( node );\n\n\treturn node;\n};\n\n/**\n * Sets the end index of the root node to the end of the text.\n *\n * @param {module:tree/structure.Node} tree The tree of which to set the root node's end index.\n *\n * @returns {void}\n *\n * @private\n */\nconst setEndIndexRootNode = function( tree ) {\n\tlet endIndexRootNode = 0;\n\ttree.forEach( node => {\n\t\tendIndexRootNode = Math.max( node.sourceEndIndex, endIndexRootNode );\n\t} );\n\ttree.sourceEndIndex = endIndexRootNode;\n};\n\n/**\n * Cleans up the given tree after parsing of the HTML source code.\n *\n * These steps are setting the start and end index of each node and\n * deleting attributes needed for parsing, but not needed for further analysis.\n *\n * @param {module:tree/structure.Node} tree The tree structure to be cleaned.\n * @param {string} html                     The original HTML source code.\n *\n * @returns {module:tree/structure.Node} The cleaned up tree.\n *\n * @private\n */\nconst cleanUpTree = function( tree, html ) {\n\ttree.map( node => cleanUpNode( node, html ) );\n\tsetEndIndexRootNode( tree );\n\treturn tree;\n};\n\nexport default cleanUpTree;\n"]}