{"version":3,"sources":["../../../../src/tree/builder/TreeAdapter.js"],"names":["FormattingElement","Heading","LeafNode","List","ListItem","Paragraph","Ignored","StructuredNode","formattingElements","headings","ignoredHtmlElements","TreeAdapter","createElement","tag","namespace","attributes","node","includes","parsedAttributes","_parseAttributes","_parseNode","tagName","parent","parseInt","parse5attributes","length","reduce","attribute","name","value","createDocumentFragment","createCommentNode","text","content","appendChild","child","_isStructuredElement","element","location","_appendFormattingElement","children","push","formattingElement","prevChild","isExplicit","textContainer","formatting","_addOrphanedFormattingElement","ancestor","_findAncestorLeafNode","paragraph","detachNode","index","indexOf","splice","insertText","appendText","_addFormattingElementText","_addStructuredNodeText","getTagName","getNamespaceURI","getDocumentMode","documentMode","setDocumentMode","mode","getParentNode","getChildNodes","getFirstChild","setNodeSourceCodeLocation","getNodeSourceCodeLocation"],"mappings":"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","file":"TreeAdapter.js","sourcesContent":["// Tree elements.\nimport FormattingElement from \"../structure/FormattingElement\";\nimport Heading from \"../structure/nodes/Heading\";\nimport LeafNode from \"../structure/nodes/LeafNode\";\nimport List from \"../structure/nodes/List\";\nimport ListItem from \"../structure/nodes/ListItem\";\nimport Paragraph from \"../structure/nodes/Paragraph\";\nimport Ignored from \"../structure/nodes/Ignored\";\nimport StructuredNode from \"../structure/nodes/StructuredNode\";\n// HTML classes.\nimport { formattingElements, headings, ignoredHtmlElements } from \"./htmlConstants\";\n\n/**\n * An adapter to parse the HTML source code to a structured tree representation, to be used in further analysis,\n * in combination with the `parse5` library.\n *\n * Implements the `parse5` library's `TreeAdapter` interface.\n * @see https://github.com/inikulin/parse5/blob/master/packages/parse5/docs/tree-adapter/interface.md\n *\n * @memberOf module:tree/builder\n *\n * @private\n */\nclass TreeAdapter {\n\t// Creation of nodes and other tree elements.\n\n\t/**\n\t * Creates a new element to be put in the tree.\n\t *\n\t * @param {string} tag                                        The HTML tag.\n\t * @param {string} namespace                                  The XML namespace (e.g. \"http://www.w3.org/1999/xhtml\" for HTML).\n\t * @param {Array<{ name: string, value: string }>} attributes The attributes of this element.\n\t *\n\t * @returns {module:tree/structure.Node|module:tree/structure.FormattingElement} The new element.\n\t */\n\tcreateElement( tag, namespace, attributes ) {\n\t\tlet node;\n\n\t\tif ( ignoredHtmlElements.includes( tag ) ) {\n\t\t\t// Ignored for analysis (e.g. `script`, `style`).\n\t\t\tnode = new Ignored( tag );\n\t\t} else if ( formattingElements.includes( tag ) ) {\n\t\t\t// Formatting element.\n\t\t\tconst parsedAttributes = TreeAdapter._parseAttributes( attributes );\n\t\t\tnode = new FormattingElement( tag, parsedAttributes );\n\t\t} else {\n\t\t\t// Paragraphs, Headers, Lists, ListItems and other nodes.\n\t\t\tnode = TreeAdapter._parseNode( tag );\n\t\t}\n\n\t\t/*\n\t\t  We need to add the tag name for `parse5`\n\t\t  to track the still open HTML elements correctly.\n\t\t  (E.g. when it encounters a closing tag, it know which element needs to be closed).\n\t\t */\n\t\tnode.tagName = tag;\n\t\tnode.namespace = namespace;\n\t\tnode.parent = null;\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Makes a new node to add to the tree, based on the given HTML-tag.\n\t *\n\t * @param {string} tag The HTML-tag of the element to add.\n\t *\n\t * @returns {module:tree/structure.Node} The node to add to the tree.\n\t *\n\t * @private\n\t */\n\tstatic _parseNode( tag ) {\n\t\tif ( headings.includes( tag ) ) {\n\t\t\t// Heading.\n\t\t\treturn new Heading( parseInt( tag[ 1 ], 10 ) );\n\t\t} else if ( tag === \"p\" ) {\n\t\t\t// Paragraph.\n\t\t\treturn new Paragraph( tag );\n\t\t} else if ( tag === \"ol\" || tag === \"ul\" ) {\n\t\t\t// List.\n\t\t\treturn new List( tag === \"ol\" );\n\t\t} else if ( tag === \"li\" ) {\n\t\t\t// List item.\n\t\t\treturn new ListItem();\n\t\t}\n\t\t// All other elements (`div`, `section`).\n\t\treturn new StructuredNode( tag );\n\t}\n\n\t/**\n\t * Parses the HTML element attributes from parse5's format to a plain JS object.\n\t * E.g. `{ name: \"id\", value: \"an-id\" }` becomes ` { id: \"an-id\" }`.\n\t *\n\t * @param {Array<{ name: string, value: string }>} parse5attributes The attributes as parsed by parse5.\n\t *\n\t * @returns {Object} The parsed attributes.\n\t *\n\t * @private\n\t */\n\tstatic _parseAttributes( parse5attributes ) {\n\t\tif ( parse5attributes && parse5attributes.length > 0 ) {\n\t\t\treturn parse5attributes.reduce( ( attributes, attribute ) => {\n\t\t\t\tattributes[ attribute.name ] = attribute.value;\n\t\t\t\treturn attributes;\n\t\t\t}, {} );\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Creates a new empty document fragment (e.g. a part of an HTML document).\n\t *\n\t * @returns {StructuredNode} A new empty document fragment.\n\t */\n\tcreateDocumentFragment() {\n\t\treturn new StructuredNode( \"root\" );\n\t}\n\n\t/**\n\t * Creates a new node representing an HTML-comment.\n\t *\n\t * @param {string} text The comment text.\n\t *\n\t * @returns {Ignored} The node representing the comment.\n\t */\n\tcreateCommentNode( text ) {\n\t\tconst node = new Ignored( \"comment\" );\n\t\tnode.parent = null;\n\t\tnode.content = text;\n\t\treturn node;\n\t}\n\n\t// Tree manipulation.\n\n\t/**\n\t * Appends a child node to a parent node.\n\t *\n\t * @param {Node} parent The parent node.\n\t * @param {Node} child  The child to add to the parent node.\n\t *\n\t * @returns {void}\n\t */\n\tappendChild( parent, child ) {\n\t\t/*\n\t\t  Do not do anything with ignored content.\n\t\t  (We get the raw string contents later on from the source code).\n\t\t */\n\t\tif ( parent instanceof Ignored ) {\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t  Structured (ignored) nodes can also be contained within headings, paragraphs\n\t\t  and formatting elements, even though it is not entirely valid HTML,\n\t\t  so we need to transform it to a FormattingElement and add it\n\t\t  to the appropriate heading or paragraph ancestor.\n\t\t */\n\t\tif ( TreeAdapter._isStructuredElement( child ) &&\n\t\t\t( parent instanceof FormattingElement || parent instanceof LeafNode ) ) {\n\t\t\t// Add structured (ignored) node as formatting to the first header or paragraph ancestor.\n\t\t\tconst element = new FormattingElement( child.tagName );\n\t\t\telement.location = child.location;\n\t\t\tTreeAdapter._appendFormattingElement( parent, element );\n\t\t\treturn;\n\t\t}\n\n\t\t// Add formatting element to its first ancestor that is either a heading or paragraph.\n\t\tif ( child instanceof FormattingElement ) {\n\t\t\tTreeAdapter._appendFormattingElement( parent, child );\n\t\t\treturn;\n\t\t}\n\n\t\t// Just add nodes to parent's children in any other case.\n\t\tchild.parent = parent;\n\t\tparent.children.push( child );\n\t}\n\n\t/**\n\t * Appends the formatting element to the tree.\n\t *\n\t * @param {Node} parent                          The (current) parent of the formatting element.\n\t * @param {FormattingElement} formattingElement  The formatting element to add to the tree.\n\t *\n\t * @returns {void}\n\t *\n\t * @private\n\t */\n\tstatic _appendFormattingElement( parent, formattingElement ) {\n\t\tformattingElement.parent = parent;\n\t\tif ( parent instanceof StructuredNode ) {\n\t\t\t/*\n\t\t\t  If the previous child is an implicit paragraph (\"[p]\"),\n\t\t\t  we should add the formatting element to it, instead of making a new paragraph.\n\n\t\t\t  E.g. in the case of `<div>[p]Hello [/p]<em>World!</em></div>`,\n\t\t\t  \"<em>World!</em>\" should be added to \"[p]Hello [p]\".\n\t\t\t */\n\t\t\tconst prevChild = parent.children[ parent.children.length - 1 ];\n\t\t\tif ( prevChild && prevChild instanceof Paragraph && ! prevChild.isExplicit() ) {\n\t\t\t\t// Add it to the implicit paragraph.\n\t\t\t\tprevChild.textContainer.formatting.push( formattingElement );\n\t\t\t\tformattingElement.parent = prevChild;\n\t\t\t} else {\n\t\t\t\t// Wrap it in a new implicit paragraph, add it as formatting.\n\t\t\t\tTreeAdapter._addOrphanedFormattingElement( parent, formattingElement );\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t Formatting elements can be nested, we want to add it to\n\t\t\t the most recent ancestor which is either a heading or paragraph.\n\t\t\t */\n\t\t\tconst ancestor = TreeAdapter._findAncestorLeafNode( formattingElement );\n\t\t\tif ( ancestor ) {\n\t\t\t\t// Add formatting element as formatting to the found paragraph or heading ancestor.\n\t\t\t\tformattingElement.parent = parent;\n\t\t\t\tancestor.textContainer.formatting.push( formattingElement );\n\t\t\t} else {\n\t\t\t\t// Wrap formatting element in paragraph, add it to the tree.\n\t\t\t\tTreeAdapter._addOrphanedFormattingElement( parent, formattingElement );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Wraps a formatting element in a paragraph and adds the resulting paragraph to the given parent.\n\t *\n\t * @param {Node} parent                          The parent element to add the new paragraph to.\n\t * @param {FormattingElement} formattingElement  The formatting element to wrap in a paragraph and add to the tree.\n\t *\n\t * @returns {void}\n\t *\n\t * @private\n\t */\n\tstatic _addOrphanedFormattingElement( parent, formattingElement ) {\n\t\tconst paragraph = new Paragraph();\n\t\tparagraph.location = formattingElement.location;\n\n\t\tparagraph.textContainer.formatting.push( formattingElement );\n\n\t\tparagraph.parent = parent;\n\t\tformattingElement.parent = paragraph;\n\t\tparent.children.push( paragraph );\n\t}\n\n\t/**\n\t * Detaches a node from its parent.\n\t *\n\t * @param {Node} node The node to detach from its parent.\n\t *\n\t * @returns {void}\n\t */\n\tdetachNode( node ) {\n\t\tif ( node.parent ) {\n\t\t\tconst index = node.parent.children.indexOf( node );\n\t\t\tnode.parent.children.splice( index, 1 );\n\t\t\tnode.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t * Appends text to a node in the tree.\n\t *\n\t * To which node it is appended depends on a few factors:\n\t *  1. If its parent is a paragraph or header: append the text to its text container.\n\t *  2. If its parent is a structured node: wrap text in a paragraph, add paragraph to parent.\n\t *  3. If its parent is a formatting element: append text to the most recent ancestor who is a paragraph or heading.\n\t *\n\t * @param {Node} node   The node to (try to) append the text to.\n\t * @param {string} text The text to append to the node.\n\t *\n\t * @returns {void}\n\t */\n\tinsertText( node, text ) {\n\t\t// Do not add text to ignored nodes. We are going to add it later from the source text.\n\t\tif ( node instanceof Ignored ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( node instanceof LeafNode ) {\n\t\t\t// Node may only contain formatting elements.\n\t\t\tnode.textContainer.appendText( text );\n\t\t} else if ( node instanceof FormattingElement ) {\n\t\t\tTreeAdapter._addFormattingElementText( node, text );\n\t\t} else {\n\t\t\tTreeAdapter._addStructuredNodeText( node, text );\n\t\t}\n\t}\n\n\t/**\n\t * Appends the given text to the formatting element's most recent ancestor\n\t * who is either a paragraph or a heading.\n\t *\n\t * @param {FormattingElement} formattingElement The formatting element.\n\t * @param {string} text                         The text to add.\n\t *\n\t * @returns {void}\n\t *\n\t * @private\n\t */\n\tstatic _addFormattingElementText( formattingElement, text ) {\n\t\t// Find a paragraph or header ancestor.\n\t\tconst ancestor = TreeAdapter._findAncestorLeafNode( formattingElement );\n\t\t// Append text to ancestor's text container.\n\t\tif ( ancestor ) {\n\t\t\tancestor.textContainer.appendText( text );\n\t\t}\n\t}\n\n\t/**\n\t * Appends the given text to either:\n\t *  1. The node's most recent child, if it is a paragraph or a heading.\n\t *  2. A new paragraph, if not.\n\t *\n\t * @param {StructuredNode} node The node.\n\t * @param {string} text         The text to append.\n\t *\n\t * @returns {void}\n\t *\n\t * @private\n\t */\n\tstatic _addStructuredNodeText( node, text ) {\n\t\t// Get the previous sibling of this node.\n\t\tconst prevChild = node.children[ node.children.length - 1 ];\n\t\t/*\n\t\t  If the previous child is an implicit paragraph, append the text to it,\n\t\t  instead of creating a new one in the explicit case.\n\n\t\t  E.g. implicit case: \"This is a \" + \"paragraph\" => \"This is a paragraph\"\n\t\t  Explicit case: \"<p>This is not a <p>\" + \"paragraph\" => \"<p>This is not a <p>paragraph\"\n\t\t */\n\t\tif ( prevChild && prevChild instanceof Paragraph && ! prevChild.isExplicit() ) {\n\t\t\t// Append text to the paragraph.\n\t\t\tprevChild.textContainer.appendText( text );\n\t\t} else {\n\t\t\t// Else: wrap the text in an implicit paragraph and add it as a new child.\n\t\t\tconst paragraph = new Paragraph();\n\t\t\tparagraph.textContainer.appendText( text );\n\t\t\tparagraph.parent = node;\n\t\t\tnode.children.push( paragraph );\n\t\t}\n\t}\n\n\t// Node getters and setters.\n\n\t/**\n\t * Returns this node's tag name.\n\t * (e.g. \"h1\", \"p\", \"comment\", \"h3\", \"div\")\n\t *\n\t * This is used by `parse5` to be able to differentiate between different\n\t * behavior of HTML elements.\n\t *\n\t * @param {Node} node The node to get the tag name from.\n\t *\n\t * @returns {string} The node's tag name.\n\t */\n\tgetTagName( node ) {\n\t\treturn node.tagName;\n\t}\n\n\t/**\n\t * Returns this node's namespace URI.\n\t * (e.g. \"http://www.w3.org/1999/xhtml\" for HTML)\n\t *\n\t * This is used by `parse5` to differentiate between parsing\n\t * HTML, SVG and other XML schema types.\n\t *\n\t * @param {Node} node The node to get the namespace URI from.\n\t *\n\t * @returns {string} The namespace URI of this node.\n\t */\n\tgetNamespaceURI( node ) {\n\t\treturn node.namespace;\n\t}\n\n\t/**\n\t * Gets the mode of the given element (e.g. \"quirks\", \"no-quirks\" or \"limited-quirks\").\n\t *\n\t * This is needed by the `parse5` library to be able to parse certain texts.\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode\n\t *\n\t * @param {module:tree/structure.Node} element The element to set the mode of.\n\t *\n\t * @returns {void}\n\t */\n\tgetDocumentMode( element ) {\n\t\treturn element.documentMode;\n\t}\n\n\t/**\n\t * Sets the mode of the given element (e.g. \"quirks\", \"no-quirks\" or \"limited-quirks\").\n\t *\n\t * This is needed by the `parse5` library to be able to parse certain texts.\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode\n\t *\n\t * @param {module:tree/structure.Node} element         The element to set the mode of.\n\t * @param {\"no-quirks\"|\"quirks\"|\"limited-quirks\"} mode The mode to set.\n\t *\n\t * @returns {void}\n\t */\n\tsetDocumentMode( element, mode ) {\n\t\telement.documentMode = mode;\n\t}\n\n\n\t/**\n\t * Returns this node's parent node.\n\t *\n\t * @param {Node} node The node from which to retrieve the parent.\n\t *\n\t * @returns {Node} The parent of this node.\n\t */\n\tgetParentNode( node ) {\n\t\treturn node.parent;\n\t}\n\n\t/**\n\t * Returns the children of the given node.\n\t *\n\t * If the node does not have any children and cannot get any (e.g. Heading, FormattingElement)\n\t * this function returns an empty list.\n\t *\n\t * @param {Node} node The node to get the children from.\n\t *\n\t * @returns {Node[]} The children of the given node.\n\t */\n\tgetChildNodes( node ) {\n\t\t/*\n\t\t  Some node types do not have children (like Paragraph and Heading),\n\t\t  but parse5 always expects a node to have children.\n\t\t */\n\t\treturn node.children || [];\n\t}\n\n\t/**\n\t * Gets a parent's first child.\n\t *\n\t * @see https://en.wikipedia.org/wiki/Rumpelstiltskin\n\t *\n\t * @param {Node} node The node to get its first child from.\n\t *\n\t * @returns {Node[]|null} The node's first child or null, if this node cannot get any children.\n\t */\n\tgetFirstChild( node ) {\n\t\tif ( node.children && node.children.length > 0 ) {\n\t\t\treturn node.children[ 0 ];\n\t\t}\n\t\treturn null;\n\t}\n\n\t// Node source location.\n\n\t/**\n\t * Sets the node's location as found in the source code.\n\t *\n\t * More often than not this is not the entire info\n\t * and misses the location of the end tag...\n\t *\n\t * We still need to add it, since `parse5` appends the end tag position\n\t * to this object somewhere during parsing (after `createElement` and before `appendChild`).\n\t *\n\t * @param {Node} node         The node to set its location.\n\t * @param {Location} location The node's location in the source code.\n\t *\n\t * @returns {void}\n\t */\n\tsetNodeSourceCodeLocation( node, location ) {\n\t\tif ( ! node ) {\n\t\t\treturn;\n\t\t}\n\t\tnode.location = location;\n\t}\n\n\t/**\n\t * Gets the node's source code location.\n\t *\n\t * @param {Node} node The node to get its source code location from.\n\t *\n\t * @returns {Location|void} The node's source code location.\n\t */\n\tgetNodeSourceCodeLocation( node ) {\n\t\tif ( ! node ) {\n\t\t\treturn;\n\t\t}\n\t\treturn node.location;\n\t}\n\n\t// Private utility methods.\n\n\t/**\n\t * Finds the most recent leaf node ancestor (parent of parent of ... ) of the given element.\n\t * (A leaf node is a node that may only contain text and formatting elements, like a heading or a paragraph).\n\t *\n\t * @see module:tree/structure.LeafNode.\n\t *\n\t * @param {Node|FormattingElement} element  The node to find the ancestor of.\n\t *\n\t * @returns {Node|null} The most recent ancestor that returns true on the given predicate, or `null` if no appropriate ancestor is found.\n\t *\n\t * @private\n\t */\n\tstatic _findAncestorLeafNode( element ) {\n\t\tlet parent = element.parent;\n\t\t/*\n\t\t  Go up the tree until we either find the element we want,\n\t\t  or until we are at the root of the tree (an element with no parent).\n\t\t */\n\t\twhile ( ! ( parent instanceof LeafNode ) && parent !== null ) {\n\t\t\tparent = parent.parent;\n\t\t}\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Checks whether the given element is either a structured or ignored node.\n\t *\n\t * @param {Node} element The element to check.\n\t *\n\t * @returns {boolean} `true` if the element is indeed a structured element.\n\t *\n\t * @private\n\t */\n\tstatic _isStructuredElement( element ) {\n\t\treturn element instanceof StructuredNode || element instanceof Ignored;\n\t}\n}\n\nexport default TreeAdapter;\n"]}