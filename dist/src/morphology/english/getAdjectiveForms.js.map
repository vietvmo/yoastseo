{"version":3,"sources":["../../../../src/morphology/english/getAdjectiveForms.js"],"names":["countSyllablesInText","createRulesFromMorphologyData","buildOneFormFromRegex","buildTwoFormsFromRegex","isUndefined","uniq","unique","flatten","checkIrregulars","word","irregularAdjectives","irregulars","forEach","paradigm","wordInParadigm","checkWordTooLong","endsWithEr","wordLength","length","substring","endsWithEst","endsWithLy","getBase","comparativeToBaseRegex","superlativeToBaseRegex","adverbToBaseRegex","base","guessedForm","getAdjectiveForms","adjectiveData","irregular","forms","regexAdjective","ically","icallyAdverbs","concat","comparativeToBase","superlativeToBase","adverbToBase","push","adverb","noComparativeOrSuperlative","RegExp","test","filter","Boolean","comparative","superlative"],"mappings":"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","file":"getAdjectiveForms.js","sourcesContent":["// \"use strict\";\nimport countSyllablesInText from \"../../stringProcessing/syllables/count\";\nimport createRulesFromMorphologyData from \"../morphoHelpers/createRulesFromMorphologyData.js\";\nimport { buildOneFormFromRegex, buildTwoFormsFromRegex } from \"../morphoHelpers/buildFormRule\";\n\nimport { isUndefined } from \"lodash-es\";\nimport { uniq as unique } from \"lodash-es\";\nimport { flatten } from \"lodash-es\";\n\n/**\n * Checks if the input word occurs in the list of irregular adjectives and if so returns all its irregular forms.\n *\n * @param {string} word The word for which to determine its irregular forms.\n * @param {Array} irregularAdjectives The list of irregular adjectives.\n *\n * @returns {Array} Array of word forms from the exception list.\n */\nconst checkIrregulars = function( word, irregularAdjectives ) {\n\tlet irregulars;\n\n\tirregularAdjectives.forEach( function( paradigm ) {\n\t\tparadigm.forEach( function( wordInParadigm ) {\n\t\t\tif ( wordInParadigm === word ) {\n\t\t\t\tirregulars = paradigm;\n\t\t\t}\n\t\t} );\n\t} );\n\treturn irregulars;\n};\n\n/**\n * Checks if the input word is longer than 2 syllables (in this case comparative and superlative forms do not need to be formed).\n *\n * @param {string} word The word for which to determine its length.\n *\n * @returns {boolean} True if the input word is longer than 2 syllables.\n */\nconst checkWordTooLong = function( word ) {\n\treturn countSyllablesInText( word, \"en_EN\" ) > 2;\n};\n\n/**\n * Checks if the input word ends with \"er\".\n *\n * @param {string} word The word to check.\n *\n * @returns {boolean} True if the word ends with \"er\".\n */\nconst endsWithEr = function( word ) {\n\tconst wordLength = word.length;\n\t// Consider only words of four letters or more to be comparatives (otherwise, words like \"per\" are being treated as comparatives).\n\tif ( wordLength > 3 ) {\n\t\treturn word.substring( word.length - 2, word.length ) === \"er\";\n\t}\n\treturn false;\n};\n\n/**\n * Checks if the input word ends with \"est\".\n *\n * @param {string} word The word to check.\n *\n * @returns {boolean} True if the word ends with \"est\".\n */\nconst endsWithEst = function( word ) {\n\tconst wordLength = word.length;\n\t// Consider only words of five letters or more to be superlatives (otherwise, words like \"test\" are being treated as superlatives).\n\tif ( wordLength > 4 ) {\n\t\treturn word.substring( word.length - 3, word.length ) === \"est\";\n\t}\n\treturn false;\n};\n\n/**\n * Checks if the input word ends with \"ly\".\n *\n * @param {string} word The word to check.\n *\n * @returns {boolean} True if the word ends with \"ly\".\n */\nconst endsWithLy = function( word ) {\n\tconst wordLength = word.length;\n\t// Consider only words of four letters or more to be adjectives (otherwise, words like \"lily\" are being treated as adjectives).\n\tif ( wordLength > 3 ) {\n\t\treturn word.substring( word.length - 2, word.length ) === \"ly\";\n\t}\n\treturn false;\n};\n\n\n/**\n * Forms the base form from an input word.\n *\n * @param {string} word The word to build the base form for.\n * @param {Array} comparativeToBaseRegex The Array of regex-based rules to bring comparatives to base.\n * @param {Array} superlativeToBaseRegex The Array of regex-based rules to bring superlatives to base.\n * @param {Array} adverbToBaseRegex The Array of regex-based rules to bring adverbs to base.\n *\n * @returns {string} The base form of the input word.\n */\nconst getBase = function( word, comparativeToBaseRegex, superlativeToBaseRegex, adverbToBaseRegex ) {\n\tif ( endsWithEr( word ) ) {\n\t\treturn {\n\t\t\tbase: buildOneFormFromRegex( word, comparativeToBaseRegex ),\n\t\t\tguessedForm: \"er\",\n\t\t};\n\t}\n\n\tif ( endsWithEst( word ) ) {\n\t\treturn {\n\t\t\tbase: buildOneFormFromRegex( word, superlativeToBaseRegex ),\n\t\t\tguessedForm: \"est\",\n\t\t};\n\t}\n\n\tif ( endsWithLy( word ) ) {\n\t\treturn {\n\t\t\tbase: buildOneFormFromRegex( word, adverbToBaseRegex ),\n\t\t\tguessedForm: \"ly\",\n\t\t};\n\t}\n\n\treturn {\n\t\tbase: word,\n\t\tguessedForm: \"base\",\n\t};\n};\n\n/**\n * Collects all possible verb forms for a given word through checking if it is irregular, base, adverb,\n * adverb ending in -ically, comparative, or superlative.\n *\n * @param {string} word The word for which to determine its forms.\n * @param {Object} adjectiveData The morphologyData available for this language.\n *\n * @returns {Array} Array of word forms.\n */\nconst getAdjectiveForms = function( word, adjectiveData ) {\n\tconst irregular = checkIrregulars( word, adjectiveData.irregularAdjectives );\n\tif ( ! isUndefined( irregular ) ) {\n\t\treturn irregular;\n\t}\n\n\tlet forms = [];\n\n\tconst regexAdjective = adjectiveData.regexAdjective;\n\tconst ically = buildTwoFormsFromRegex( word, createRulesFromMorphologyData( regexAdjective.icallyAdverbs ) );\n\tif ( ! isUndefined( ically ) ) {\n\t\treturn ically.concat( word );\n\t}\n\n\tconst comparativeToBaseRegex = createRulesFromMorphologyData( regexAdjective.comparativeToBase );\n\tconst superlativeToBaseRegex = createRulesFromMorphologyData( regexAdjective.superlativeToBase );\n\tconst adverbToBaseRegex = createRulesFromMorphologyData( regexAdjective.adverbToBase );\n\n\tlet base = getBase( word, comparativeToBaseRegex, superlativeToBaseRegex, adverbToBaseRegex ).base;\n\n\tif ( isUndefined( base ) ) {\n\t\tbase = word;\n\t}\n\n\t// Const guessedForm = getBase( word ).guessedForm; //Meant to be used to check if the newly built forms are built correctly.\n\tforms = forms.concat( word );\n\n\tforms.push( base );\n\tforms.push( buildOneFormFromRegex( base, createRulesFromMorphologyData( regexAdjective.adverb ) ) );\n\n\tconst noComparativeOrSuperlative = new RegExp( regexAdjective.noComparativeOrSuperlative, \"i\" );\n\tif ( checkWordTooLong( base ) === true || noComparativeOrSuperlative.test( base ) === true ) {\n\t\treturn unique( forms.filter( Boolean ) );\n\t}\n\n\tforms.push( buildOneFormFromRegex( base, createRulesFromMorphologyData( regexAdjective.comparative ) ) );\n\tforms.push( buildOneFormFromRegex( base, createRulesFromMorphologyData( regexAdjective.superlative ) ) );\n\n\treturn unique( flatten( forms.filter( Boolean ) ) );\n};\n\nexport {\n\tgetAdjectiveForms,\n\tgetBase,\n};\n"]}