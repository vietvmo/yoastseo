{"version":3,"sources":["../../../src/values/Participle.js"],"names":["defaults","forEach","isString","getType","isSameType","defaultAttributes","auxiliaries","type","language","validateAttributes","attributes","attributeValue","attributeName","expectedType","Error","Participle","participle","sentencePart","setParticiple","setSentencePart","_determinesSentencePartIsPassive","_attributes","prototype","_participle","getParticiple","_sentencePart","getSentencePart","getAuxiliaries","getLanguage","determinesSentencePartIsPassive","setSentencePartPassiveness","passive","serialize","_parseClass","parse","serialized"],"mappings":"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","file":"Participle.js","sourcesContent":["import { defaults, forEach, isString } from \"lodash-es\";\n\nimport { getType, isSameType } from \"./../helpers/types\";\n\n/**\n * Default attributes to be used by the Participle if they are left undefined.\n * @type { { auxiliaries: array, type: string } }\n */\nvar defaultAttributes = {\n\tauxiliaries: [],\n\ttype: \"\",\n\tlanguage: \"\",\n};\n\n/**\n * Validates the type of all attributes. Throws an error if the type is invalid.\n *\n * @param {object} attributes The object containing all attributes.\n * @returns {void}\n */\nvar validateAttributes = function( attributes ) {\n\tforEach( attributes, function( attributeValue, attributeName ) {\n\t\tvar expectedType = getType( defaultAttributes[ attributeName ] );\n\t\tif ( isSameType( attributeValue, expectedType ) === false ) {\n\t\t\tthrow Error( \"Attribute \" + attributeName + \" has invalid type. Expected \" + expectedType + \", got \" + getType( attributeValue ) + \".\" );\n\t\t}\n\t} );\n};\n\n/**\n * Construct the Participle object and set the participle, sentence part, auxiliary and type.\n *\n * @param {string} participle The participle.\n * @param {string} sentencePart The sentence part where the participle is from.\n * @param {object} attributes The object containing all attributes.\n * @constructor\n */\nvar Participle = function( participle, sentencePart, attributes ) {\n\tthis.setParticiple( participle );\n\tthis.setSentencePart( sentencePart );\n\tthis._determinesSentencePartIsPassive = false;\n\n\tattributes = attributes || {};\n\n\tdefaults( attributes, defaultAttributes );\n\n\tvalidateAttributes( attributes );\n\n\tthis._attributes = attributes;\n};\n\n/**\n * Sets the participle.\n * @param {string} participle The participle.\n * @returns {void}.\n */\nParticiple.prototype.setParticiple = function( participle ) {\n\tif ( participle === \"\" ) {\n\t\tthrow Error( \"The participle should not be empty.\" );\n\t}\n\tif ( ! isString( participle ) ) {\n\t\tthrow Error( \"The participle should be a string.\" );\n\t}\n\tthis._participle = participle;\n};\n\n/**\n * Returns the participle.\n * @returns {String} The participle.\n */\nParticiple.prototype.getParticiple = function() {\n\treturn this._participle;\n};\n\n/**\n * Sets the SentencePart.\n *\n * @param {string} sentencePart The sentence part.\n * @returns {void}.\n */\nParticiple.prototype.setSentencePart = function( sentencePart ) {\n\tif ( sentencePart === \"\" ) {\n\t\tthrow Error( \"The sentence part should not be empty.\" );\n\t}\n\tthis._sentencePart = sentencePart;\n};\n\n/**\n * Returns the sentence part.\n * @returns {String} The sentence part.\n */\nParticiple.prototype.getSentencePart = function() {\n\treturn this._sentencePart;\n};\n\n/**\n * Returns the type.\n * @returns {String} The type.\n */\nParticiple.prototype.getType = function() {\n\treturn this._attributes.type;\n};\n\n/**\n * Returns the auxiliaries.\n * @returns {String} The auxiliaries.\n */\nParticiple.prototype.getAuxiliaries = function() {\n\treturn this._attributes.auxiliaries;\n};\n\n/**\n * Returns the language.\n * @returns {string} The language.\n */\nParticiple.prototype.getLanguage = function() {\n\treturn this._attributes.language;\n};\n\n/**\n * Returns if the participle is passive or not.\n * @returns {boolean} True if it is passive.\n */\nParticiple.prototype.determinesSentencePartIsPassive = function() {\n\treturn this._determinesSentencePartIsPassive;\n};\n\n/**\n * Determines if the sentence is passive or not.\n * @param {boolean} passive Whether the sentence part is passive.\n * @returns {void}\n */\nParticiple.prototype.setSentencePartPassiveness = function( passive ) {\n\tif ( ! isSameType( passive, \"boolean\" ) ) {\n\t\tthrow Error( \"Passiveness had invalid type. Expected boolean, got \" + getType( passive ) + \".\" );\n\t}\n\tthis._determinesSentencePartIsPassive = passive;\n};\n\n/**\n * Serializes the Participle instance to an object.\n *\n * @returns {Object} The serialized Participle.\n */\nParticiple.prototype.serialize = function() {\n\treturn {\n\t\t_parseClass: \"Participle\",\n\t\tattributes: this._attributes,\n\t\tparticiple: this._participle,\n\t\tsentencePart: this._sentencePart,\n\t\tdeterminesSentencePartIsPassive: this._determinesSentencePartIsPassive,\n\t};\n};\n\n/**\n * Parses the object to a Participle.\n *\n * @param {Object} serialized The serialized object.\n *\n * @returns {Participle} The parsed Participle.\n */\nParticiple.parse = function( serialized ) {\n\tconst participle = new Participle( serialized.participle, serialized.sentencePart, serialized.attributes );\n\tparticiple.setSentencePartPassiveness( serialized.determinesSentencePartIsPassive );\n\n\treturn participle;\n};\n\nexport default Participle;\n"]}