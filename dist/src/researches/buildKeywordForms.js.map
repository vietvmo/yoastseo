{"version":3,"sources":["../../../src/researches/buildKeywordForms.js"],"names":["getFormsForLanguageFactory","getFormsForLanguage","getWords","getLanguage","getFunctionWordsFactory","getFunctionWords","parseSynonyms","getVariationsApostrophe","getVariationsApostropheInArray","includes","filter","isUndefined","escapeRegExp","uniq","unique","flatten","get","memoize","filterFunctionWords","array","language","functionWords","length","arrayFiltered","word","all","trim","toLocaleLowerCase","buildForms","keyphrase","morphologyData","doubleQuotes","substring","concat","words","forms","getForms","forEach","wordToLowerCase","push","formsOfThisWord","variationsApostrophes","Boolean","collectKeyphraseAndSynonymsForms","synonyms","synonymsSplit","keyphraseForms","synonymsForms","map","synonym","primeMorphologyData","collectForms","collectFormsWithMorphologyData","research","paper","researcher","getLocale","getData","getKeyword","getSynonyms"],"mappings":"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","file":"buildKeywordForms.js","sourcesContent":["import getFormsForLanguageFactory from \"../helpers/getFormsForLanguage.js\";\nconst getFormsForLanguage = getFormsForLanguageFactory();\nimport getWords from \"../stringProcessing/getWords.js\";\nimport getLanguage from \"../helpers/getLanguage.js\";\nimport getFunctionWordsFactory from \"../helpers/getFunctionWords.js\";\nconst getFunctionWords = getFunctionWordsFactory();\nimport parseSynonyms from \"../stringProcessing/parseSynonyms\";\nimport { getVariationsApostrophe } from \"../stringProcessing/getVariationsApostrophe\";\nimport { getVariationsApostropheInArray } from \"../stringProcessing/getVariationsApostrophe\";\n\nimport { includes } from \"lodash-es\";\nimport { filter } from \"lodash-es\";\nimport { isUndefined } from \"lodash-es\";\nimport { escapeRegExp } from \"lodash-es\";\nimport { uniq as unique } from \"lodash-es\";\nimport { flatten } from \"lodash-es\";\nimport { get } from \"lodash-es\";\nimport { memoize } from \"lodash-es\";\n\n/**\n * Filters function words from an array of words based on the language.\n *\n * @param {Array} array The words to check.\n * @param {string} language The language to take function words for.\n *\n * @returns {Array} The original array with the function words filtered out.\n */\nconst filterFunctionWords = function( array, language ) {\n\tif ( isUndefined( language ) || language === \"\" ) {\n\t\tlanguage = \"en\";\n\t}\n\n\tconst functionWords = get( getFunctionWords, [ language ], [] );\n\n\tif ( array.length > 1 ) {\n\t\tconst arrayFiltered = filter( array, function( word ) {\n\t\t\treturn ( ! includes( functionWords.all, word.trim().toLocaleLowerCase() ) );\n\t\t} );\n\n\t\tif ( arrayFiltered.length > 0 ) {\n\t\t\treturn arrayFiltered;\n\t\t}\n\t}\n\n\treturn array;\n};\n\n/**\n * Analyzes the focus keyword string. Checks if morphology is requested or if the user wants to match exact string.\n * If morphology is required the module builds all word forms for all words (if no function words list available) or\n * for all content words (i.e., excluding prepositions, articles, conjunctions, if the function words list is available).\n *\n * @param {string} keyphrase The keyphrase of the paper (or a synonym phrase) to get forms for.\n * @param {string} language The language to use for morphological analyzer and for function words.\n * @param {Object} morphologyData The available morphology data per language (false if unavailable).\n *\n * @returns {Array} Array of all forms to be searched for keyword-based assessments.\n */\nconst buildForms = function( keyphrase, language, morphologyData ) {\n\tif ( isUndefined( keyphrase ) || keyphrase === \"\" ) {\n\t\treturn [];\n\t}\n\n\t/*\n\t * If the keyphrase is embedded in double quotation marks, return keyword itself, without outer-most quotation marks.\n\t * Additionally, provide apostrophe variations.\n\t */\n\n\tconst doubleQuotes = [ \"“\", \"”\", \"〝\", \"〞\", \"〟\", \"‟\", \"„\", \"\\\"\" ];\n\tif ( includes( doubleQuotes, keyphrase[ 0 ] ) && includes( doubleQuotes, keyphrase[ keyphrase.length - 1 ] ) ) {\n\t\tkeyphrase = keyphrase.substring( 1, keyphrase.length - 1 );\n\t\treturn [ unique( [].concat( escapeRegExp( keyphrase ), getVariationsApostrophe( keyphrase ) ) ) ];\n\t}\n\n\tconst words = filterFunctionWords( getWords( keyphrase ), language );\n\n\tconst forms = [];\n\n\tconst getForms = getFormsForLanguage[ language ];\n\t/*\n\t * Only returns the keyword and the keyword with apostrophe variations if morphological forms cannot be built.\n\t * Otherwise additionally returns the morphological forms.\n\t */\n\tif ( morphologyData === false || isUndefined( getForms ) ) {\n\t\twords.forEach( function( word ) {\n\t\t\tconst wordToLowerCase = escapeRegExp( word.toLocaleLowerCase( language ) );\n\n\t\t\tforms.push( unique( [].concat( wordToLowerCase, getVariationsApostrophe( wordToLowerCase ) ) ) );\n\t\t} );\n\t} else {\n\t\twords.forEach( function( word ) {\n\t\t\tconst wordToLowerCase = escapeRegExp( word.toLocaleLowerCase() );\n\t\t\tconst formsOfThisWord = getForms( wordToLowerCase, morphologyData );\n\t\t\tconst variationsApostrophes = getVariationsApostropheInArray( formsOfThisWord );\n\t\t\tforms.push( unique( flatten( formsOfThisWord.concat( variationsApostrophes ) ) ).filter( Boolean ) );\n\t\t} );\n\t}\n\n\treturn forms;\n};\n\n/**\n * Builds morphological forms of words of the keyphrase and of each synonym phrase.\n *\n * @param {string} keyphrase The paper's keyphrase.\n * @param {string} synonyms The paper's synonyms.\n * @param {string} language The paper's language.\n * @param {Object} morphologyData The available morphology data to be used by the getForms function (language specific).\n *\n * @returns {Object} Object with an array of keyphrase forms and an array of arrays of synonyms forms.\n */\nconst collectKeyphraseAndSynonymsForms = function( keyphrase, synonyms, language = \"en\", morphologyData ) {\n\tconst synonymsSplit = parseSynonyms( synonyms );\n\n\tconst keyphraseForms = buildForms( keyphrase, language, morphologyData );\n\tconst synonymsForms = synonymsSplit.map( synonym => buildForms( synonym, language, morphologyData ) );\n\n\treturn {\n\t\tkeyphraseForms: keyphraseForms,\n\t\tsynonymsForms: synonymsForms,\n\t};\n};\n\n/**\n * Caches morphological forms depending on the currently available morphologyData and (separately) keyphrase, synonyms,\n * and language. In this way, if the morphologyData remains the same in multiple calls of this function, the function\n * that collects actual morphological forms only needs to check if the keyphrase, synonyms and language also remain the\n * same to return the cached result. The joining of keyphrase, synonyms and language for this function is needed,\n * because by default memoize caches by the first key only, which in the current case would mean that the function would\n * return the cached forms if the keyphrase has not changed (without checking if synonyms and language were changed).\n *\n * @param {Object|boolean} morphologyData The available morphology data.\n *\n * @returns {function} The function that collects the forms for a given set of keyphrase, synonyms, language and\n * morphologyData.\n */\nconst primeMorphologyData = memoize( ( morphologyData ) => {\n\treturn memoize( ( keyphrase, synonyms, language = \"en\" ) => {\n\t\treturn collectKeyphraseAndSynonymsForms( keyphrase, synonyms, language, morphologyData );\n\t}, ( keyphrase, synonyms, language ) => {\n\t\treturn keyphrase + \",\" + synonyms + \",\" + language;\n\t} );\n} );\n\n\n/**\n * Retrieves morphological forms of words of the keyphrase and of each synonym phrase using the function that caches\n * the results of previous calls of this function.\n *\n * @param {string} keyphrase The paper's keyphrase.\n * @param {string} synonyms The paper's synonyms.\n * @param {string} language The paper's language.\n * @param {Object} morphologyData The available morphology data to be used by the getForms function (language specific).\n *\n * @returns {Object} Object with an array of keyphrase forms and an array of arrays of synonyms forms.\n */\nfunction collectForms( keyphrase, synonyms, language = \"en\", morphologyData ) {\n\tconst collectFormsWithMorphologyData = primeMorphologyData( morphologyData );\n\n\treturn collectFormsWithMorphologyData( keyphrase, synonyms, language );\n}\n\n/**\n * Calls the function that builds keyphrase and synonyms forms for a specific research data.\n *\n * @param {Paper} paper The paper to build keyphrase and synonym forms for.\n * @param {Researcher} researcher The researcher prototype.\n *\n * @returns {Object} Object with an array of keyphrase forms and an array of arrays of synonyms forms.\n */\nfunction research( paper, researcher ) {\n\tconst language = getLanguage( paper.getLocale() );\n\n\tconst morphologyData = get( researcher.getData( \"morphology\" ), [ language ], false );\n\n\treturn collectForms( paper.getKeyword(), paper.getSynonyms(), language, morphologyData );\n}\n\nexport {\n\tfilterFunctionWords,\n\tbuildForms,\n\tcollectForms,\n\tresearch,\n};\n"]}