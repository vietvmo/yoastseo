{"version":3,"sources":["../../../../../../src/researches/passiveVoice/periphrastic/freeAuxiliaryParticipleOrder/nonDirectParticiplePrecedenceException.js"],"names":["uniq","arrayToRegex","getWordIndices","cannotBeBetweenAuxiliaryAndParticiplePolishFactory","cannotBeBetweenAuxiliaryAndParticiplePolish","cannotBeBetweenPassiveAuxiliaryAndParticiple","getIndicesByWordListSorted","sentencePart","participle","auxiliaries","language","auxiliariesUnique","auxiliaryIndices","participleIndex","indexOf","nonDirectParticiplePrecendenceExceptionRegex","matches","filter","auxiliaryIndex","index","length","participleAuxiliary","precedenceExceptionIndices","remaningPrecedenceExceptionIndices","precedenceExceptionIndex"],"mappings":"AAAA,SAASA,IAAT,QAAqB,WAArB;;AAEA,OAAOC,YAAP,MAAyB,sDAAzB;AACA,OAAOC,cAAP,MAA2B,2BAA3B;;AAEA,OAAOC,kDAAP,MAA+D,kCAA/D;;AAEA,MAAMC,8CACND,qDAAqDE,4CADrD;AAEA,SAASC,0BAAT,QAA2C,yCAA3C;;AAGA;;;;;;;;;;;AAWA,eAAe,UAAUC,YAAV,EAAwBC,UAAxB,EAAoCC,WAApC,EAAiDC,QAAjD,EAA4D;AAC1E,OAAMC,oBAAoBX,KAAMS,WAAN,CAA1B;;AAEA,OAAMG,mBAAmBN,2BAA4BK,iBAA5B,EAA+CJ,YAA/C,CAAzB;;AAEA,OAAMM,kBAAkBN,aAAaO,OAAb,CAAsBN,UAAtB,CAAxB;AACA,KAAIO,4CAAJ;;AAEA,SAASL,QAAT;AACC,OAAK,IAAL;AACCK,kDAA+Cd,aAAcG,2CAAd,CAA/C;AACA;AAHF;;AAMA;AACA,OAAMY,UAAUJ,iBAAiBK,MAAjB,CAAyBC,kBAAkBA,eAAeC,KAAf,GAAuBN,eAAlE,CAAhB;;AAEA;AACA,KAAKG,QAAQI,MAAR,KAAmB,CAAxB,EAA4B;AAC3B,SAAO,KAAP;AACA;;AAED;AACA,OAAMC,sBAAsBL,QAASA,QAAQI,MAAR,GAAiB,CAA1B,CAA5B;;AAEA,OAAME,6BAA6BpB,eAAgBK,YAAhB,EAA8BQ,4CAA9B,CAAnC;;AAEA;AACA,OAAMQ,qCAAqCD,2BAA2BL,MAA3B,CAAmCO,4BAC3EA,yBAAyBL,KAAzB,GAAiCE,oBAAoBF,KAArD,IAA8DK,yBAAyBL,KAAzB,GAAiCN,eADvD,CAA3C;;AAGA,QAAOU,mCAAmCH,MAAnC,GAA4C,CAAnD;AACA","file":"nonDirectParticiplePrecedenceException.js","sourcesContent":["import { uniq } from \"lodash-es\";\n\nimport arrayToRegex from \"../../../../stringProcessing/createRegexFromArray.js\";\nimport getWordIndices from \"../getIndicesWithRegex.js\";\n\nimport cannotBeBetweenAuxiliaryAndParticiplePolishFactory from \"../../../polish/functionWords.js\";\n\nconst cannotBeBetweenAuxiliaryAndParticiplePolish =\ncannotBeBetweenAuxiliaryAndParticiplePolishFactory().cannotBeBetweenPassiveAuxiliaryAndParticiple;\nimport { getIndicesByWordListSorted } from \"../../../../stringProcessing/indices.js\";\n\n\n/**\n * Checks whether there are any exception words in between the auxiliary and participle. If there are, it doesn't return a passive.\n *\n * @param {string} sentencePart The sentence part that contains the participle.\n * @param {string} participle The participle in the sentence part.\n * @param {string} auxiliaries One or more auxiliaries in the sentence part.\n * @param {string} language The language of the participle.\n *\n * @returns {boolean} Returns true if a word from the 'cannot be between passive auxiliary and participle' exception list\n * appears anywhere in between the last (closest to participle) auxiliary and the participle.\n */\nexport default function( sentencePart, participle, auxiliaries, language ) {\n\tconst auxiliariesUnique = uniq( auxiliaries );\n\n\tconst auxiliaryIndices = getIndicesByWordListSorted( auxiliariesUnique, sentencePart );\n\n\tconst participleIndex = sentencePart.indexOf( participle );\n\tlet nonDirectParticiplePrecendenceExceptionRegex;\n\n\tswitch ( language ) {\n\t\tcase \"pl\":\n\t\t\tnonDirectParticiplePrecendenceExceptionRegex = arrayToRegex( cannotBeBetweenAuxiliaryAndParticiplePolish );\n\t\t\tbreak;\n\t}\n\n\t// This exception is only applicable for passive constructions in which the auxiliary precedes the participle.\n\tconst matches = auxiliaryIndices.filter( auxiliaryIndex => auxiliaryIndex.index < participleIndex );\n\n\t// If there are no auxiliaries before the participle, this exception is not applicable.\n\tif ( matches.length === 0 ) {\n\t\treturn false;\n\t}\n\n\t// We pick the auxiliary closest to the participle, since that is most likely the one belonging to the participle.\n\tconst participleAuxiliary = matches[ matches.length - 1 ];\n\n\tconst precedenceExceptionIndices = getWordIndices( sentencePart, nonDirectParticiplePrecendenceExceptionRegex );\n\n\t// Check whether there are any precendence words between the auxiliary and the participle.\n\tconst remaningPrecedenceExceptionIndices = precedenceExceptionIndices.filter( precedenceExceptionIndex =>\n\t\t( precedenceExceptionIndex.index > participleAuxiliary.index && precedenceExceptionIndex.index < participleIndex ) );\n\n\treturn remaningPrecedenceExceptionIndices.length > 0;\n}\n"]}