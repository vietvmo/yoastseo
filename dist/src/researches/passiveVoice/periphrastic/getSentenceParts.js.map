{"version":3,"sources":["../../../../../src/researches/passiveVoice/periphrastic/getSentenceParts.js"],"names":["indicesProcessing","getIndicesOfList","getIndicesByWordList","filterIndices","sortIndices","stripSpaces","normalizeSingle","normalizeSingleQuotes","arrayToRegex","getWordIndices","includesIndex","followsIndex","filter","isUndefined","includes","map","forEach","SentencePartEnglish","auxiliariesEnglishFactory","stopwordsEnglishFactory","auxiliariesEnglish","all","stopwordsEnglish","stopCharacterRegexEnglish","verbEndingInIngRegex","ingExclusionArray","SentencePartFrench","auxiliariesFrenchFactory","auxiliariesFrench","stopwordsFrenchFactory","stopwordsFrench","stopCharacterRegexFrench","followingAuxiliaryExceptionWordsFrench","reflexivePronounsFrench","directPrecedenceExceptionRegexFrench","elisionAuxiliaryExceptionWords","elisionAuxiliaryExceptionRegex","SentencePartSpanish","auxiliariesSpanishFactory","auxiliariesSpanish","stopwordsSpanishFactory","stopwordsSpanish","followingAuxiliaryExceptionWordsSpanish","SentencePartItalian","auxiliariesItalianFactory","auxiliariesItalian","stopwordsItalianFactory","stopwordsItalian","followingAuxiliaryExceptionWordsItalian","reflexivePronounsItalian","directPrecedenceExceptionRegexItalian","stopCharacterRegexOthers","languageVariables","en","stopwords","auxiliaryRegex","SentencePart","auxiliaries","stopCharacterRegex","fr","followingAuxiliaryExceptionRegex","directPrecedenceExceptionRegex","es","it","getVerbsEndingInIng","sentence","matches","match","getStopCharacters","language","lastIndex","exec","push","index","auxiliaryPrecedenceExceptionFilter","text","auxiliaryMatches","directPrecedenceExceptionMatches","auxiliaryMatch","auxiliaryObject","followingAuxiliaryExceptionFilter","followingAuxiliaryExceptionMatches","elisionAuxiliaryExceptionFilter","elisionAuxiliaryExceptionMatches","getSentenceBreakers","toLocaleLowerCase","auxiliaryIndices","stopwordIndices","stopCharacterIndices","indices","concat","ingVerbs","ingVerbsIndices","getAuxiliaryMatches","sentencePart","auxiliaryMatchIndices","auxiliaryMatchWords","auxiliaryMatchIndex","getSentenceParts","sentenceParts","i","length","endIndex","substr"],"mappings":"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","file":"getSentenceParts.js","sourcesContent":["import indicesProcessing from \"../../../stringProcessing/indices\";\nconst getIndicesOfList = indicesProcessing.getIndicesByWordList;\nconst filterIndices = indicesProcessing.filterIndices;\nconst sortIndices = indicesProcessing.sortIndices;\nimport stripSpaces from \"../../../stringProcessing/stripSpaces.js\";\nimport { normalizeSingle as normalizeSingleQuotes } from \"../../../stringProcessing/quotes.js\";\nimport arrayToRegex from \"../../../stringProcessing/createRegexFromArray.js\";\nimport getWordIndices from \"./getIndicesWithRegex.js\";\nimport includesIndex from \"../../../stringProcessing/includesIndex\";\nimport followsIndex from \"../../../stringProcessing/followsIndex\";\n\nimport { filter } from \"lodash-es\";\nimport { isUndefined } from \"lodash-es\";\nimport { includes } from \"lodash-es\";\nimport { map } from \"lodash-es\";\nimport { forEach } from \"lodash-es\";\n\n// English-specific variables and imports.\nimport SentencePartEnglish from \"../../english/passiveVoice/SentencePart\";\n\nimport auxiliariesEnglishFactory from \"../../english/passiveVoice/auxiliaries.js\";\nimport stopwordsEnglishFactory from \"../../english/passiveVoice/stopwords.js\";\nconst auxiliariesEnglish = auxiliariesEnglishFactory().all;\n\nconst stopwordsEnglish = stopwordsEnglishFactory();\nconst stopCharacterRegexEnglish = /([:,]|('ll)|('ve))(?=[ \\n\\r\\t'\"+\\-»«‹›<>])/ig;\nconst verbEndingInIngRegex = /\\w+ing(?=$|[ \\n\\r\\t.,'()\"+\\-;!?:/»«‹›<>])/ig;\nconst ingExclusionArray = [ \"king\", \"cling\", \"ring\", \"being\", \"thing\", \"something\", \"anything\" ];\n\n// French-specific variables and imports.\nimport SentencePartFrench from \"../../french/passiveVoice/SentencePart\";\n\nimport auxiliariesFrenchFactory from \"../../french/passiveVoice/auxiliaries.js\";\nconst auxiliariesFrench = auxiliariesFrenchFactory();\nimport stopwordsFrenchFactory from \"../../french/passiveVoice/stopwords.js\";\nconst stopwordsFrench = stopwordsFrenchFactory();\nconst stopCharacterRegexFrench = /(,)(?=[ \\n\\r\\t'\"+\\-»«‹›<>])/ig;\nconst followingAuxiliaryExceptionWordsFrench = [ \"le\", \"la\", \"les\", \"une\", \"l'un\", \"l'une\" ];\nconst reflexivePronounsFrench = [ \"se\", \"me\", \"te\", \"s'y\", \"m'y\", \"t'y\", \"nous nous\", \"vous vous\" ];\nconst directPrecedenceExceptionRegexFrench = arrayToRegex( reflexivePronounsFrench );\nconst elisionAuxiliaryExceptionWords = [ \"c'\", \"s'\", \"peut-\" ];\nconst elisionAuxiliaryExceptionRegex = arrayToRegex( elisionAuxiliaryExceptionWords, true );\n\n// Spanish-specific variables and imports.\nimport SentencePartSpanish from \"../../spanish/passiveVoice/SentencePart\";\n\nimport auxiliariesSpanishFactory from \"../../spanish/passiveVoice/auxiliaries.js\";\nconst auxiliariesSpanish = auxiliariesSpanishFactory();\nimport stopwordsSpanishFactory from \"../../spanish/passiveVoice/stopwords.js\";\nconst stopwordsSpanish = stopwordsSpanishFactory();\nconst followingAuxiliaryExceptionWordsSpanish = [ \"el\", \"la\", \"los\", \"las\", \"una\" ];\n\n// Italian-specific variables and imports.\nimport SentencePartItalian from \"../../italian/passiveVoice/SentencePart\";\n\nimport auxiliariesItalianFactory from \"../../italian/passiveVoice/auxiliaries.js\";\nconst auxiliariesItalian = auxiliariesItalianFactory();\nimport stopwordsItalianFactory from \"../../italian/passiveVoice/stopwords.js\";\nconst stopwordsItalian = stopwordsItalianFactory();\nconst followingAuxiliaryExceptionWordsItalian = [ \"il\", \"i\", \"la\", \"le\", \"lo\", \"gli\", \"uno\", \"una\" ];\nconst reflexivePronounsItalian = [ \"mi\", \"ti\", \"si\", \"ci\", \"vi\" ];\nconst directPrecedenceExceptionRegexItalian = arrayToRegex( reflexivePronounsItalian );\n\n/*\n * Variables applying to multiple languages\n * This regex applies to Spanish and Italian\n */\nconst stopCharacterRegexOthers = /([:,])(?=[ \\n\\r\\t'\"+\\-»«‹›<>])/ig;\n\n\n// The language-specific variables used to split sentences into sentence parts.\nconst languageVariables = {\n\ten: {\n\t\tstopwords: stopwordsEnglish,\n\t\tauxiliaryRegex: arrayToRegex( auxiliariesEnglish ),\n\t\tSentencePart: SentencePartEnglish,\n\t\tauxiliaries: auxiliariesEnglish,\n\t\tstopCharacterRegex: stopCharacterRegexEnglish,\n\t},\n\tfr: {\n\t\tstopwords: stopwordsFrench,\n\t\tauxiliaryRegex: arrayToRegex( auxiliariesFrench ),\n\t\tSentencePart: SentencePartFrench,\n\t\tauxiliaries: auxiliariesFrench,\n\t\tstopCharacterRegex: stopCharacterRegexFrench,\n\t\tfollowingAuxiliaryExceptionRegex: arrayToRegex( followingAuxiliaryExceptionWordsFrench ),\n\t\tdirectPrecedenceExceptionRegex: directPrecedenceExceptionRegexFrench,\n\t},\n\tes: {\n\t\tstopwords: stopwordsSpanish,\n\t\tauxiliaryRegex: arrayToRegex( auxiliariesSpanish ),\n\t\tSentencePart: SentencePartSpanish,\n\t\tauxiliaries: auxiliariesSpanish,\n\t\tstopCharacterRegex: stopCharacterRegexOthers,\n\t\tfollowingAuxiliaryExceptionRegex: arrayToRegex( followingAuxiliaryExceptionWordsSpanish ),\n\t},\n\tit: {\n\t\tstopwords: stopwordsItalian,\n\t\tauxiliaryRegex: arrayToRegex( auxiliariesItalian ),\n\t\tSentencePart: SentencePartItalian,\n\t\tauxiliaries: auxiliariesItalian,\n\t\tstopCharacterRegex: stopCharacterRegexOthers,\n\t\tfollowingAuxiliaryExceptionRegex: arrayToRegex( followingAuxiliaryExceptionWordsItalian ),\n\t\tdirectPrecedenceExceptionRegex: directPrecedenceExceptionRegexItalian,\n\t},\n};\n\n/**\n * Gets active verbs (ending in ing) to determine sentence breakers in English.\n *\n * @param {string} sentence The sentence to get the active verbs from.\n * @returns {Array} The array with valid matches.\n */\nconst getVerbsEndingInIng = function( sentence ) {\n\t// Matches the sentences with words ending in ing.\n\tconst matches = sentence.match( verbEndingInIngRegex ) || [];\n\t// Filters out words ending in -ing that aren't verbs.\n\treturn filter( matches, function( match ) {\n\t\treturn ! includes( ingExclusionArray, stripSpaces( match ) );\n\t} );\n};\n\n/**\n * Gets stop characters to determine sentence breakers.\n *\n * @param {string} sentence The sentence to get the stop characters from.\n * @param {string} language The language for which to get the stop characters.\n * @returns {Array} The array with stop characters.\n */\nconst getStopCharacters = function( sentence, language ) {\n\tconst stopCharacterRegex = languageVariables[ language ].stopCharacterRegex;\n\tlet match;\n\tconst matches = [];\n\n\tstopCharacterRegex.lastIndex = 0;\n\n\twhile ( ( match = stopCharacterRegex.exec( sentence ) ) !== null ) {\n\t\tmatches.push(\n\t\t\t{\n\t\t\t\tindex: match.index,\n\t\t\t\tmatch: match[ 0 ],\n\t\t\t}\n\t\t);\n\t}\n\treturn matches;\n};\n\n/**\n * Filters auxiliaries preceded by a reflexive pronoun.\n *\n * @param {string} text The text part in which to check.\n * @param {Array} auxiliaryMatches The auxiliary matches for which to check.\n * @param {string} language The language for which to check auxiliary precedence exceptions.\n *\n * @returns {Array} The filtered list of auxiliary indices.\n */\nconst auxiliaryPrecedenceExceptionFilter = function( text, auxiliaryMatches, language ) {\n\tconst directPrecedenceExceptionMatches = getWordIndices( text, languageVariables[ language ].directPrecedenceExceptionRegex );\n\n\tforEach( auxiliaryMatches, function( auxiliaryMatch ) {\n\t\tif ( includesIndex( directPrecedenceExceptionMatches, auxiliaryMatch.index ) ) {\n\t\t\tauxiliaryMatches = auxiliaryMatches.filter( function( auxiliaryObject ) {\n\t\t\t\treturn auxiliaryObject.index !== auxiliaryMatch.index;\n\t\t\t} );\n\t\t}\n\t} );\n\n\treturn auxiliaryMatches;\n};\n\n/**\n * Filters auxiliaries followed by a word on the followingAuxiliaryExceptionWords list.\n *\n * @param {string} text The text part in which to check.\n * @param {Array} auxiliaryMatches The auxiliary matches for which to check.\n * @param {string} language The language for which to filter the auxiliaries.\n * @returns {Array} The filtered list of auxiliary indices.\n */\nconst followingAuxiliaryExceptionFilter = function( text, auxiliaryMatches, language ) {\n\tconst followingAuxiliaryExceptionRegex = languageVariables[ language ].followingAuxiliaryExceptionRegex;\n\tconst followingAuxiliaryExceptionMatches = getWordIndices( text, followingAuxiliaryExceptionRegex );\n\n\tforEach( auxiliaryMatches, function( auxiliaryMatch ) {\n\t\tif ( followsIndex( followingAuxiliaryExceptionMatches, auxiliaryMatch ) ) {\n\t\t\tauxiliaryMatches = auxiliaryMatches.filter( function( auxiliaryObject ) {\n\t\t\t\treturn auxiliaryObject.index !== auxiliaryMatch.index;\n\t\t\t} );\n\t\t}\n\t} );\n\n\treturn auxiliaryMatches;\n};\n\n/**\n * Filters auxiliaries preceded by an elided word (e.g., s') on the elisionAuxiliaryExceptionWords list.\n *\n * @param {string} text The text part in which to check.\n * @param {Array} auxiliaryMatches The auxiliary matches for which to check.\n * @returns {Array} The filtered list of auxiliary indices.\n */\nconst elisionAuxiliaryExceptionFilter = function( text, auxiliaryMatches ) {\n\tconst elisionAuxiliaryExceptionMatches = getWordIndices( text, elisionAuxiliaryExceptionRegex );\n\n\tforEach( auxiliaryMatches, function( auxiliaryMatch ) {\n\t\tif ( includesIndex( elisionAuxiliaryExceptionMatches, auxiliaryMatch.index, false ) ) {\n\t\t\tauxiliaryMatches = auxiliaryMatches.filter( function( auxiliaryObject ) {\n\t\t\t\treturn auxiliaryObject.index !== auxiliaryMatch.index;\n\t\t\t} );\n\t\t}\n\t} );\n\n\treturn auxiliaryMatches;\n};\n\n/**\n * Gets the indexes of sentence breakers (auxiliaries, stopwords and stop characters;\n * in English also active verbs) to determine sentence parts.\n * Indices are filtered because there could be duplicate matches, like \"even though\" and \"though\".\n * In addition, 'having' will be matched both as a -ing verb as well as an auxiliary.\n *\n * @param {string} sentence The sentence to check for indices of sentence breakers.\n * @param {string} language The language for which to match the sentence breakers.\n * @returns {Array} The array with valid indices to use for determining sentence parts.\n */\nconst getSentenceBreakers = function( sentence, language ) {\n\tsentence = sentence.toLocaleLowerCase();\n\tconst stopwords = languageVariables[ language ].stopwords;\n\tconst auxiliaries = languageVariables[ language ].auxiliaries;\n\tlet auxiliaryIndices = getIndicesOfList( auxiliaries, sentence );\n\tconst stopwordIndices = getIndicesOfList( stopwords, sentence );\n\tconst stopCharacterIndices = getStopCharacters( sentence, language );\n\tlet indices;\n\n\t// Concat all indices arrays, filter them and sort them.\n\tswitch ( language ) {\n\t\tcase \"fr\":\n\t\t\t// Filters auxiliaries matched in the sentence based on a precedence exception filter.\n\t\t\tauxiliaryIndices = auxiliaryPrecedenceExceptionFilter( sentence, auxiliaryIndices, \"fr\" );\n\t\t\t// Filters auxiliaries matched in the sentence based on a elision exception filter.\n\t\t\tauxiliaryIndices = elisionAuxiliaryExceptionFilter( sentence, auxiliaryIndices );\n\n\t\t\tindices = [].concat( auxiliaryIndices, stopwordIndices, stopCharacterIndices );\n\t\t\tbreak;\n\t\tcase \"es\":\n\t\t\tindices = [].concat( auxiliaryIndices, stopwordIndices, stopCharacterIndices );\n\t\t\tbreak;\n\t\tcase \"it\":\n\t\t\t// Filters auxiliaries matched in the sentence based on a precedence exception filter.\n\t\t\tauxiliaryIndices = auxiliaryPrecedenceExceptionFilter( sentence, auxiliaryIndices, \"it\" );\n\t\t\tindices = [].concat( auxiliaryIndices, stopwordIndices, stopCharacterIndices );\n\t\t\tbreak;\n\t\tcase \"en\":\n\t\tdefault:\n\t\t\tvar ingVerbs = getVerbsEndingInIng( sentence );\n\t\t\tvar ingVerbsIndices = getIndicesOfList( ingVerbs, sentence );\n\t\t\tindices = [].concat( auxiliaryIndices, stopwordIndices, ingVerbsIndices, stopCharacterIndices );\n\t\t\tbreak;\n\t}\n\tindices = filterIndices( indices );\n\treturn sortIndices( indices );\n};\n\n/**\n * Gets the auxiliaries from a sentence.\n *\n * @param {string} sentencePart The part of the sentence to match for auxiliaries.\n * @param {string} language The language for which to match the auxiliaries.\n * @returns {Array} All formatted matches from the sentence part.\n */\nconst getAuxiliaryMatches = function( sentencePart, language ) {\n\tconst auxiliaryRegex = languageVariables[ language ].auxiliaryRegex;\n\tconst auxiliaryMatches = sentencePart.match( auxiliaryRegex ) || [];\n\n\tswitch ( language ) {\n\t\tcase \"fr\":\n\t\tcase \"es\":\n\t\tcase \"it\":\n\t\t\t// An array with the matched auxiliaries and their indices.\n\t\t\tvar auxiliaryMatchIndices = getIndicesOfList( auxiliaryMatches, sentencePart );\n\n\t\t\tif ( ( language ===  \"fr\" ) || ( language === \"it\" ) ) {\n\t\t\t\t// Filters auxiliaries matched in the sentence part based on a precedence exception filter.\n\t\t\t\tauxiliaryMatchIndices = auxiliaryPrecedenceExceptionFilter( sentencePart, auxiliaryMatchIndices, language );\n\t\t\t}\n\t\t\t// Filters auxiliaries matched in the sentence part based on a exception filter for words following the auxiliary.\n\t\t\tauxiliaryMatchIndices = followingAuxiliaryExceptionFilter( sentencePart, auxiliaryMatchIndices, language );\n\n\t\t\t// An array with the matched auxiliary verbs (without indices).\n\t\t\tvar auxiliaryMatchWords = [];\n\n\t\t\tforEach( auxiliaryMatchIndices, function( auxiliaryMatchIndex ) {\n\t\t\t\tauxiliaryMatchWords.push( auxiliaryMatchIndex.match );\n\t\t\t} );\n\n\t\t\treturn map( auxiliaryMatchWords, function( auxiliaryMatch ) {\n\t\t\t\treturn stripSpaces( auxiliaryMatch );\n\t\t\t} );\n\t\tcase \"en\":\n\t\tdefault:\n\t\t\treturn map( auxiliaryMatches, function( auxiliaryMatch ) {\n\t\t\t\treturn stripSpaces( auxiliaryMatch );\n\t\t\t} );\n\t}\n};\n\n/**\n * Gets the sentence parts from a sentence by determining sentence breakers.\n *\n * @param {string} sentence The sentence to split up in sentence parts.\n * @param {string} language The language for which to get the sentence parts.\n * @returns {Array} The array with all parts of a sentence that have an auxiliary.\n */\nconst getSentenceParts = function( sentence, language ) {\n\tconst sentenceParts = [];\n\tconst auxiliaryRegex = languageVariables[ language ].auxiliaryRegex;\n\tconst SentencePart = languageVariables[ language ].SentencePart;\n\n\tsentence = normalizeSingleQuotes( sentence );\n\n\t// First check if there is an auxiliary in the sentence.\n\tif ( sentence.match( auxiliaryRegex ) === null ) {\n\t\treturn sentenceParts;\n\t}\n\n\tconst indices = getSentenceBreakers( sentence, language );\n\t// Get the words after the found auxiliary.\n\tfor ( let i = 0; i < indices.length; i++ ) {\n\t\tlet endIndex = sentence.length;\n\t\tif ( ! isUndefined( indices[ i + 1 ] ) ) {\n\t\t\tendIndex = indices[ i + 1 ].index;\n\t\t}\n\n\t\t// Cut the sentence from the current index to the endIndex (start of next breaker, of end of sentence).\n\t\tconst sentencePart = stripSpaces( sentence.substr( indices[ i ].index, endIndex - indices[ i ].index ) );\n\n\t\tconst auxiliaryMatches = getAuxiliaryMatches( sentencePart, language );\n\t\t// If a sentence part doesn't have an auxiliary, we don't need it, so it can be filtered out.\n\t\tif ( auxiliaryMatches.length !== 0 ) {\n\t\t\tsentenceParts.push( new SentencePart( sentencePart, auxiliaryMatches ) );\n\t\t}\n\t}\n\treturn sentenceParts;\n};\n\n/**\n * Split the sentence in sentence parts based on auxiliaries.\n *\n * @param {string} sentence The sentence to split in parts.\n * @param {string} language The language for which to get the sentence parts.\n * @returns {Array} A list with sentence parts.\n */\nexport default function( sentence, language ) {\n\treturn getSentenceParts( sentence, language );\n}\n"]}